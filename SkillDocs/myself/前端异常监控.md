## 异常捕获与性能监控

1. 运行时错误，接口调用异常等
2. 资源加载错误，图片加载失败等

### 异常捕获方式

#### try catch

可以捕获运行时错误，同步的

缺点：

+ 影响代码可读性，代码变得臃肿
+ 不可捕获语法错误
+ 不可以捕获异步错误

#### window.onerror（全局）

只能捕获即时运行错误，不能捕获资源加载错误

```javascript
window.onerror = function(errorMessage, scriptURI, lineNo, columnNo, error) {
    console.log('errorMessage: ' + errorMessage); // 异常信息
    console.log('scriptURI: ' + scriptURI); // 异常文件路径
    console.log('lineNo: ' + lineNo); // 异常行号
    console.log('columnNo: ' + columnNo); // 异常列号
    console.log('error: ' + error); // 异常堆栈信息
};
```

#### object.onerror（捕获资源加载错误）

img标签、script标签都可以添加onerror事件，用来捕获资源加载错误；

#### performance.getEntries

可以获取所有已加载资源的加载时间，通过这种方式，可以间接的拿到没有加载的资源错误

1. 获取网站成功加载的资源数量信息：

```js
performance.getEntries().forEach(
    function(item){
        console.log(item.name)
 })
Copy
```

2. 再输入document.getElementsByTagName('img')，就会显示出所有的img集合，这是所有需要加载的图片的集合；
3. document.getElementsByTagName('img')获取的资源数组减去通过performance.getEntries()获取的资源数组，剩下的就是没有成功加载的，这种方式可以间接的捕获到资源加载错误。

### 异常捕获常见问题

#### 跨域脚本无法准确捕获异常

对`script`标签增加一个`crossorigin=”anonymous”`，并且服务器添加`Access-Control-Allow-Origin`。

```html
<script src="http://cdn.xxx.com/index.js" crossorigin="anonymous"></script>
```

#### sourceMap

生产环境下的代码是经过`webpack`打包后压缩混淆的代码,我们发现所有的报错的代码行数都在第一行了.

推荐的是在服务端使用`Node.js`对接收到的日志信息时使用`source-map`解析，以避免源代码的泄露造成风险，如下代码所示：

```javascript
const express = require('express');
const fs = require('fs');
const router = express.Router();
const sourceMap = require('source-map');
const path = require('path');
const resolve = file => path.resolve(__dirname, file);
// 定义post接口
router.get('/error/', async function(req, res) {
    // 获取前端传过来的报错对象
    let error = JSON.parse(req.query.error);
    let url = error.scriptURI; // 压缩文件路径
    if (url) {
        let fileUrl = url.slice(url.indexOf('client/')) + '.map'; // map文件路径
        // 解析sourceMap
        let consumer = await new sourceMap.SourceMapConsumer(fs.readFileSync(resolve('../' + fileUrl), 'utf8')); // 返回一个promise对象
        // 解析原始报错数据
        let result = consumer.originalPositionFor({
            line: error.lineNo, // 压缩后的行号
            column: error.columnNo // 压缩后的列号
        });
        console.log(result);
    }
});
module.exports = router;
```

#### Vue捕获异常

在`Vue`中，异常可能被`Vue`自身给`try ... catch`了，不会传到`window.onerror`事件触发。

使用[Vue.config.errorHandler](https://cn.vuejs.org/v2/api/#errorHandler)这样的`Vue`全局配置，可以在`Vue`指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和`Vue` 实例。

```javascript
Vue.config.errorHandler = function (err, vm, info) {
  // handle error
  // `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子
  // 只在 2.2.0+ 可用
}
```

### 性能监控

#### 性能监控指标

1. 白屏时间：从打开网站到有内容渲染出来的时间节点；
2. 首屏时间：首屏内容渲染完毕的时间节点；
3. 用户可操作时间节点：domready触发节点；
4. 总下载时间：window.onload的触发节点。

#### window.performance

`timing`对象包含延迟相关的性能信息。

### 日志上报

#### 单独的日志域名

#### 跨域的问题

- 一种是构造空的`Image`对象的方式，其原因是请求图片并不涉及到跨域的问题；

```
var url = 'xxx';
new Image().src = url;
```

- 利用`Ajax`上报日志，必须对日志服务器接口开启跨域请求头部`Access-Control-Allow-Origin:*`，这里`Ajax`就并不强制使用`GET`请求了，即可克服`URL`长度限制的问题。

#### 省去响应主体

对于我们上报日志，其实对于客户端来说，并不需要考虑上报的结果,所以上报来说，其实使用`HEAD`请求就够了，接口返回空的结果，最大地减少上报日志造成的资源浪费。

#### 合并上报

