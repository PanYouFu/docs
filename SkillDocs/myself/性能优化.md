## 加载时性能优化

页面加载过程如下：

解析URL，DNS域名解析，建立TCP连接，发送HTTP请求，服务器返回资源，断开连接

### 优化点概括

1. DNS解析优化、
2. 减少HTTP请求数量
3. 减小HTTP请求大小
4. 使用HTTP2
5. 静态资源使用CDN
6. 使用浏览器缓存
7. 服务端渲染

#### DNS解析优化

DNS解析流程：浏览器缓存 ->系统缓存 ->路由器缓存 ->ISP DNS缓存 ->递归搜索

使用**DNS预解析**进行优化

```html
<meta http-equiv="x-dns-prefetch-control" content="on" />
```

页面header中使用link标签来强制对DNS预解析

```html
<link rel="dns-prefetch" href="http://bdimg.share.baidu.com" />
```

### 使用HTTP2

HTTP2的优点：解析速度快、多路复用、首部压缩、服务端推送

#### 解析速度快

服务器解析 HTTP2 的请求，不需要想http1.X版本那样不断地读入字符，直到遇到分隔符 CRLF 为止。HTTP2 是基于帧的协议，每个帧都有表示帧长度的字段。

#### 多路复用

在 HTTP2 上，多个请求可以共用一个 TCP 连接。同样是基于帧跟流实现的。

**多路复用与http1.1长连接的区别**

- HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；
- HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；
- HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；

#### 首部压缩

压缩头部信息，能够节省消息头占用的网络的流量

#### 服务器推送

服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。

例：访问到入口页面时，即服务端主动推送入口页同名的CSS与JS资源。

### 减少HTTP请求数量与大小

+ 压缩文件 - 减少HTTP请求大小，可以减少请求时间
+ 文件合并 - 减少请求数量

#### webpack压缩文件插件

+ JS压缩 - UglifyPlugin
+ CSS压缩 - MiniCssExtractPlugin
+ Html压缩 - HtmlWebpackPlugin
+ 图片压缩 - image-webpack-loader

#### 提取公共代码

提取项目中多次使用到的公共代码进行提取，打包成公共模块。

**webpack4 ,optimization属性，使用runtimeChunk，splitChunks**

```javascript
optimization: {
    runtimeChunk: {
        name: 'manifest' // 将 webpack 的 runtime 代码拆分为一个单独的 chunk。
    },
    splitChunks: {
        cacheGroups: {
            vendor: {
                name: 'chunk-vendors',
                test: /[\\/]node_modules[\\/]/,
                priority: -10,
                chunks: 'initial'
            },
            common: {
                name: 'chunk-common',
                minChunks: 2,
                priority: -20,
                chunks: 'initial',
                reuseExistingChunk: true
            }
        },
    }
},
```

##### runtimeChunk

**设置runtimeChunk是将包含chunks映射关系的list单独从app.js里提取出来。**每一个chunk的id基本都是基于内容hash出来的，所以你每次改动都会影响它，如果不把它提取出来的话，等于app.js每次都会改变，缓存就失效了。

设置runtimeChunk之后，webpack就会生成一个个**runtime~xxx.js**的文件。然后每次更改所谓的运行时代码文件时，打包构建时app.js的hash值是不会改变的。如果每次项目更新都会更改app.js的hash值，那么用户端浏览器每次都需要重新加载变化的app.js，如果项目大切优化分包没做好的话会导致第一次加载很耗时，导致用户体验变差。现在设置了runtimeChunk，就解决了这样的问题。所以**这样做的目的是避免文件的频繁变更导致浏览器缓存失效，所以其是更好的利用缓存。提升用户体验。**

**runtimeChunk作用是为了线上更新版本时，充分利用浏览器缓存，使用户感知的影响到最低。**

###### script-ext-html-webpack-plugin

因为每次**runtime~xxx.js**每次都会变动，所以频繁请求该文件也会损耗性能。所以可以使用`script-ext-html-webpack-plugin`插件将**runtime~xxx.js**文件内联到**index.html**中。减少Http请求。

##### splitChunks

提取被重复引入的文件，单独生成一个或多个文件，这样避免在多入口重复打包文件

**cacheGroups** 自定义配置决定生成的文件,缓存策略

- test ： 限制范围，正则匹配文件夹或文件
- name : 打包的chunks的名字
- priority : 优先级，多个分组冲突时决定把代码放在哪块
- enforce: 强制生成
- **minSize** 生成新的chunk的最小体积，默认30000B
- **minChunks**  被entry引入的次数，默认1（为1时，适合分离`node_modules`里的第三方库）
- **maxInitialRequest** entry文件最大的并行请求数（请求过多，耗时），默认5
- **maxAsyncRequests** 按需加载的时候最大的并行请求数，默认3
- **automaticNameDelimiter** 定义文件名称连接符，默认~

### 采用SVG

svg矢量图，是代码编写出来的，渲染快，放大不失真，文件体积小，可以设置属性，例如 font-size、color。

### 按需加载代码，减少冗余代码

#### **按需加载**

例子：单页面项目，会存在多个路由页面。如果将这些页面都打包进一个JS文件， 虽然减少了HTTP请求数量， 但是会导致文件比较大，同时加载了大量首页不需要的代码。

**可以使用按需加载， 将每个路由页面单独打包为一个文件**。根据文件内容生成文件名，结合 import 动态引入组件实现按需加载

通过配置 output 的 filename 属性可以实现这个需求。filename 属性的值选项中有一个 `[contenthash]`，它将根据文件内容创建出唯一 hash。当文件内容发生变化时，`[contenthash]` 也会发生变化。

```javascript
output: {
    filename: '[name].[contenthash].js',
    chunkFilename: '[name].[contenthash].js',
    path: path.resolve(__dirname, '../dist'),
},
```

#### **减少冗余代码**

避免不必要的转义：`babel-loader`用 `include` 或 `exclude` 来帮我们避免不必要的转译

其次减少ES6 转为 ES5 的冗余代码：Babel 转化后的代码想要实现和原来代码一样的功能需要借助一些帮助函数。使用babel插件进行解决

```javascript
"plugins": [
        "@babel/plugin-transform-runtime"
]
```

### 服务端渲染

客户端渲染: 获取 HTML 文件，根据需要下载 JavaScript 文件，运行文件，生成 DOM，再渲染。

服务端渲染：服务端返回 HTML 文件，客户端只需解析 HTML。

优点：首屏渲染快，SEO 好。缺点：配置麻烦，增加了服务器的计算压力。

### 使用 Defer 加载JS

尽量**将 CSS 放在文件头部，JavaScript 文件放在底部**

所有放在 head 标签里的 CSS 和 JS 文件都会堵塞渲染。如果这些 CSS 和 JS 需要加载和解析很久的话，那么页面就空白了。

因为先加载 HTML 再加载 CSS，会让用户第一时间看到的页面是没有样式的、“丑陋”的，为了避免这种情况发生，就要将 CSS 文件放在头部了。

JS 文件也不是不可以放在头部，只要给 script 标签加上 defer 属性就可以了，异步下载，延迟执行。

### 静态资源使用CDN

在webpack里配置output.publicPath: '[http://cdn.test.com](http://cdn.test.com/)'，css的输出在css-loader里配置，同样图片的输出在url-loader里配置。

### 图片优化

#### 雪碧图

雪碧图的核心原理在于设置不同的背景偏移量，大致包含两点：

- 不同的图标元素都会将 `background-url` 设置为合并后的雪碧图的 uri；
- 不同的图标通过设置对应的 `background-position` 来展示大图中对应的图标部分。

#### 图片懒加载

实现方式就是先不给图片设置路径，当图片出现在浏览器可视区域时才设置真正的图片路径。

实现上就是先将图片路径设置给`original-src`,当页面不可见时，图片不会加载：

```html
<img original-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9eb06680a16044feb794f40fc3b1ac3d~tplv-k3u1fbpfcp-watermark.image" />
```

通过监听页面滚动，等页面可见时设置图片`src`:

```javascript
const img = document.querySelector('img')
img.src = img.getAttribute("original-src")
```

#### CSS图片懒加载

```javascript
.login {
    background-url: url(/static/img/login.png);
}
```

对于上面这个样式规则，如果不应用到具体的元素，浏览器不会去下载该图片。所以你可以通过切换 `className` 的方式，放心得进行 CSS 中图片的懒加载。

------

## 运行时性能优化

### 减少回流，重绘

渲染页面过程为：

1. 解析HTML生成DOM树
2. 解析CSS生成CSSOM规则树
3. 将DOM树与CSSOM树合并生成渲染树
4. 遍历渲染树，计算每一个节点位置大小信息
5. 绘制

#### reflow 回流 重排

当改变DOM元素位置或者大小时， 会导致浏览器重新生成Render树， 这个过程叫重排

#### repaint 重绘

当重新生成渲染树后， 将要将渲染树每个节点绘制到屏幕， 这个过程叫重绘

#### 回流触发时机

**重排发生后的根本原理就是元素的几何属性发生改变**

+ 添加| 删除 可见元素
+ 元素位置发生改变
+ 元素本身尺寸发生改变
+ 内容发生变化
+ 页面初始化
+ 窗口大小变化

#### 减少回流重绘的方法

+ **避免table布局**

  不要使用table布局，可能很小的一个改动会造成整个table重新布局

+ 分离读写操作

+ **集中样式修改**

+ **position属性为absolute或fixed**

  使用绝对定位会使的该元素单独成为渲染树中 body 的一个子元素，重排开销比较小，不会对其它节点造成太多影响。

### 长列表优化

有时会有这样的需求， 需要在页面上展示包含上百个元素的列表（例如一个Feed流）。每个列表元素还有着复杂的内部结构，这显然提高了页面渲染的成本。

#### 实现虚拟列表

它的核心思想在于：只渲染可见区域附近的列表元素。

- 首先确定长列表所在父元素的大小，父元素的大小决定了可视区的宽和高
- 确定长列表每一个列表元素的宽和高，同时初始的条件下计算好长列表每一个元素相对于父元素的位置，并用一个数组来保存所有列表元素的位置信息
- 首次渲染时，只展示相对于父元素可视区内的子列表元素，在滚动时，根据父元素的滚动的`offset`重新计算应该在可视区内的子列表元素。这样保证了无论如何滚动，真实渲染出的dom节点只有可视区内的列表元素。
- 假设可视区内能展示5个子列表元素，及时长列表总共有1000个元素，但是每时每刻，真实渲染出来的dom节点只有5个。
- 补充说明，这种情况下，父元素一般使用`position：relative`，子元素的定位一般使用：`position：absolute`或`sticky`

### 防抖节流

当一个事件频繁触发，而我们希望间隔一定的时间再触发相应的函数时， 就可以使用节流（throttle）来处理

当一个事件频繁触发，而我们希望在事件触发结束一段时间后（此段时间内不再有触发）才实际触发响应函数时会使用防抖（debounce）

### 使用 Web Workers

Web Worker 是一个独立的线程（独立的执行环境），这就意味着它可以完全和 UI 线程（主线程）并行的执行 js 代码，从而不会阻塞 UI，它和主线程是通过 onmessage 和 postMessage 接口进行通信的。

Web Worker 使得网页中进行多线程编程成为可能。当主线程在处理界面事件时，worker 可以在后台运行，帮你处理大量的数据计算，当计算完成，将计算结果返回给主线程，由主线程更新 DOM 元素。

### 写代码时的优化点

+ 使用事件委托
+ switch
+ 使用flex布局





